// Последнее обновление 2018-08-10 by Phisik
// Здесь будут все переменные
// Был соблазн оставить их в основном файле, но так легче навести порядок

#include "configuration.h"
#include "declarations.h"

const char     my_version[] = "v3.86";

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Связь с внешним миром
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char  FlToGSM=10;        // Признак того, что сотовый используется для вывода информации
char  FlToUSART=0;      // Признак того, что CОМ-порт используется для вывода информации
char  FlAvtonom=0;      // Признак того, что CОМ-порт используется для вывода информации

unsigned char  WiFiAP[12] = "HOME_WIFI";
unsigned char  WiFiPass[12] = "SeCrEt";
unsigned char  PeriodRefrServer=30;
    
unsigned char  idDevice[11] = "0123456789";
unsigned char  ip[4]  = {192,168,1,2};
unsigned int   ipPort = 50000;
    
// Настройки СМС
char       my_phone[13] = "+79001234567";

char pos_rx_buffer=0;
// Отключаем часть переменных, которые связаны с вай-фай и ГСМ
// В итоге имеем почти в 2,5 раза больше свободной памяти, что должно положительно сказаться на быстродействии и стабильности
// Хотя вай-фай жаль, конечно, но он все равно локально не работает...

// Update 2018:  Отключаем все без сожаления - теперь есть MQTT

#if USE_GSM_WIFI==1
    const char sms_start[]="0410"; // SMS для старта (рестарта процесса), это большая русская буква А в формате UNICODE 
                                   // (обязательно надо использовать русские буквы, чтобы SMS гарантированно пришел в формате UNICODE, другие программа 
                                   // анализировать не может, точнее может, но надо заранее тогда знать, что придет последними 4 байтами в сообщении.
    const char sms_stop[]="0411";  // SMS для остановки процесса, это большая русская буква Б в формате UNICODE
    const char call_sms[]="0412";  // SMS для получения состояния в виде SMS  в любом случае, даже если включена отправка на сервер (большая русская буква В в UNICODE).
    const char call_gprs[]="0413"; // SMS для отключения получения состояния в виде SMS  при звонке и перевода на получения состояния через GPRS (большая русская буква Г в UNICODE).
    char       lastSMSState=0;           // Последнее отправленное состояние по SMS (Чтобы не отправлять его многократно)
    char       pdu_phone[14];  // Номер телефона в формате отправки SMS (заполняется автоматически)
    char       SMSOnCall=0;
    
    // Настройки  GPRS
    unsigned char  timeGPRS=0;   // Таймер для отсчета GPRS соединения
    unsigned char  timeWaitGPRS=0;   // Таймер для отсчета ответа соединения
    char           flNeedRefrServer=0;// Флаг того, что надо обновить данные на сервере.

    
    unsigned char  flGPRSState=0;    // Флаг состояния обработки команд.
    char           stateAfterDelete=0; // Семантика обработки команд после некотрых завершающих состояний.

    char my_gprs_buffer[MY_TX_BUFFER_SIZE];
    

    char           ErrGPRSConnectInernet=0;
    char           ErrGPRSConnectServer=0;
#endif
 
// Эти отключить не получилось...
unsigned char  timeRefrServer=0;   // Таймер для отсчета ответа соединения
char           cmdGPRS=' ';        // Посланная команда от сервера
char           cmdGPRSIsp=' ';     // Выполненная команда от сервера

char           flNeedCall=0;  // Состояние необходимости звонка по тревоге
                                  // 0 - звонить не нужно
                                  // 1 - надо позвонить
                                  // 2 - дозваниваемся
                                  // 3 - звонили, получили ответ 


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Настройка регулятора мощности
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char flCorrASC712  = 0;     // Флаг того, что надо расчитывать в данный момент среднеквадратичную мощность 1-мощность, 2-напряжение.
char CorrectASC712 = 1;     // Признак того, как надо использовать датчик asc712 
                            // (0- не надо, 1 - только показывать мощность, 2-корректировать мощность через фактический ток, 3- ПИД регулирование через ток)
                            
char flAutoDetectPowerTEN=0;   
int  FindKt=0;            // Нужный процент открытия симистора (если отрицательный, значит 
char CntPeriod=0;         //Номер обсчитываемого полу-периода

int NaprPeregrev=145;     // Какое среднеквадратичное надо поддерживать для защиты клапанов от перегрева.

unsigned char zPS=0;      // Число прерываний нуля за секунду.
unsigned char zPSOut=0;   // Число прерываний нуля за секунду для вывода на экран.


// Расчет мощности
#define MAX_TABLE_T 200
unsigned char tableS10[MAX_TABLE_T]; //табличное значение времени задежки открытия триака


//#define MAX_TABLE_SQRT 26
//unsigned char   tableSQRT[MAX_TABLE_SQRT];  //Значение корня
//unsigned int    tableSQ[MAX_TABLE_SQRT];     //Значение квадрата

unsigned long SqNaprT=0, SqNaprPrevT=0; //  Переменные для накапливания квадратов напряжений.

int NewErr;		// Новая ошибка рассогласования
int OldErrOut;	// Новая ошибка рассогласования
int OldErr;		// Старая ошибка рассогласования
int It;			// Интегральная составляющая (без коэффициентов, чтобы избавиться от дробей, коэффициенты учтем в момент ее применения);
int Dt;			// Дифференциальная составляющая (без коэффициентов, чтобы избавиться от дробей, коэффициенты учтем в момент ее применения);

int NewErrTemp;	// Новая ошибка рассогласования температуры
int OldErrTemp;	// Старая ошибка рассогласования температуры
int OldErrTempOut;	// Старая ошибка рассогласования температуры
int ItTemp;     // Интегральная составляющая температуры (без коэффициентов, чтобы избавиться от дробей, коэффициенты учтем в момент ее применения);
int DtTemp;     // Дифференциальная составляющая температуры (без коэффициентов, чтобы избавиться от дробей, коэффициенты учтем в момент ее применения);

int KtT;        // Коэффициент мощности ТЭНа в 1000 долей.

char PIDTemp[3]={
  20,10,30};    // Пропорциональный коэффициент пид-регулятора температуры [0]
// Интегральный коэффициент пид-регулятора температуры [1]
// Дифференциальный коэффициент пид-регулятора температуры [2]
unsigned char PIDTime=5;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Настройки НБК
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int  MaxPressByPeriod=0;
char minPressNBK=26;
char deltaPressNBK=25;
char timePressNBK=36;
char UprNasosNBK=1;
unsigned char SpeedNBK=0;


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Настройка таймеров и периодов
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int timeMIXER=0; // Время работы двигателя миксера в секундах. По истечении этого времени мешалка остановится
int timeNBK=0;   // Время работы насоса НБК в секундах со скоростью SpeedNKB. По истечении этого времени насос остановится
unsigned char timeBRD=0; // Таймер для отсчета времени открытия бардо-отводчика.
int time1=0;   // Таймер для отсчета секунд 1
int time2=0;   // Таймер для отсчета секунд 2
int time3=0;   // Таймер для отсчета секунд 3
int TimeStabKolonna=900; // Время стабилизации колонны (положительное значение - время от последнего изменения температуры, отрицательное - абсолютное время).
char timeOpenBRD=2; // Скорость порта, деленная на 1200



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Датчик давления
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int  U_MPX5010=0;       // Текущее значение давления (в 10 мм р.ст, то есть 100, это 10 мм рст).
int  P_MPX5010=0;       // Поправка для датчика 
int  AlarmMPX5010=0;   // Давление при котором надо выдавать сингал тревоги.
char CountAlarmMPX5010=0;   // Количество глюков, зафиксированных от датчика 


char countAlrmNPG=0;  // Количество сработок тревоги НПГ.



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Настройка датчиков температуры
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
OneWire         ds(PIN_DS18B20);  // on pin 37
uint8_t   ds1820_devices;                  // Количество датчиков ds18b20 
uint8_t   ds1820_rom_codes[MAX_DS1820][9]; // Коды датчиков ds18b20
char            ds1820_popr[MAX_DS1820];                  // Поправки к температуре датчиков
char            ds1820_flread[MAX_DS1820];                  // Поправки к температуре датчиков

#if USE_BMP280_SENSOR
	Adafruit_BMP280 bmp; // I2C

	int PressAtm=760;
	unsigned char flReadPress=0;
	unsigned char timePressAtm=60;
	char ds1820_poprPress[MAX_DS1820];                  // Поправки к температуре датчиков
#endif // USE_BMP280_SENSOR

unsigned char   CntErrDs18=0;   // Количество глюков, зафиксированных от датчика 
char            CntErrPower=0;   // Количество глюков, зафиксированных от датчика 
char            NumErrDs18=0;   // Номер сглючившего датчика
//char          NumErr=0;       // Код ошибки 1 - глючит датчик ds18b20
int             TekTemp=0; //Текущая температура для отображения
int             temps[MAX_DS1820];            // Температура датчиков  
int             MaxTemps[MAX_DS1820];           // максимальная Температура датчиков  за процесс.
unsigned char   nPopr=0;                     // Текущий датчик, которому вносится поправка




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Настройки программ
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


int    FlState=0;  // Флаг состоянияч конечного автомата обработки нажатия кнопок клавиатуры 
unsigned char  IspReg=101; // Используемый в данный момент режим (по умолчанию пока ставим регулятор мощности)
char      DispPage=0; // Какую страницу отображать на дисплее
int   TempTerm=200;
int   Delta=5;

char  BeepEndProcess=1; // Пищать динамиком по окончании процесса.
char  BeepStateProcess=2; // Пищать динамиком при переходе между процессами.
char  BeepKeyPress=0;    // Пищать динамиком при нажатии на клавиши
int   Temp1P=986;        // Температура первой (недробной) перегонки 
int   Temp2P=964;        // Температура второй  перегонки  (дистилляция без дефлегматора)
int   Temp3P=954;        // Температура третьей перегонки  (дистилляция без дефлегматора)
int   TempKipenZator=800;// Температура начала закипания затора (либо это температура в верхней части заторника (если два термометра, либо в заторнике, если стоит один термометр)
char TempZSP=50;// Температура при которой можно засыпать несоложенку.
char TempZSPSld=63;// Температура при которой можно засыпать солод.
char TempHLDZatorBrog1=36;// Температура брожения
int PowerGlvDistil=800; // Мощность отбора голов при простой дистилляции
int PowerDistil=3000; // Мощность дистилляции
int PowerNBK=2400; // Мощность дистилляции
unsigned char SpeedNBKDst=0; // Скорость насоса НБК
int PowerRazvZerno=820; // Мощность, при которой будут развариваться зерновые (2 часа).
int PowerVarkaZerno=1500; // Мощность, при которой будут варится зерновые и доводиться до кипения (она меньше, чем мощность ТЭНов, потому что на полной мощности может быть факелирование).

int TempDeflBegDistil=700; //Температура в дефлегматоре, для начала подачи воды в холодильник.
int TempDefl=820; //Температура в дефлегматоре, которую надо поддерживать путем включения клапана дефлегматора
unsigned char DeltaDefl=20; //дельта Температуры в дефлегматоре, которую надо поддерживать путем включения клапана дефлегматора
int tEndDistDefl=985;       // Температура в кубе, при которой надо прекращать дистилляцию с дефлегматором 
int timerMinute=0;          // Время для таймера
int PowerMinute=0;          // Установленная мощность
int tEndRectRazgon=-500;     // Температура окончания режима разгона 83.0 С +(температура в кубе) - (температура в колонне)
int PowerRect=750;     // Мощность ректификации
int tStabSR;// Температура, относительно которой стабилизируется отбор СР
char ProcChimSR;// Текущий процент отбора СР
long SecTempPrev;// Значение секудндомера, при котором было считана эта температура.
long SecTempPrev1;// Значение секудндомера, при котором было считана эта температура.

#if ADJUST_COLUMN_STAB_TEMP
	long SecTempPrev2;// Значение секундомера, при котором было считана эта температура.
	float lastStableT;
#endif

long SecOstatok;// Знчение секудндомера, сколько еще осталось до стабилизации
int TempPrev=0;// Значение предыдущей температуры (для сверки с текущей (проверка стабилизации значение 344 для облегчения отладки)

int tEndRectOtbGlv=870;     // Температура окончания отбора голов 85.4 С
unsigned int timeChimRectOtbGlv=60000;  // Шим отбора голов 
int ProcChimOtbGlv=-200;  // Процент ШИМ отбора голов 
unsigned int timeChimRectOtbSR=1000;  // Шим отбора голов 
char tDeltaRect=3;  // Дельта ректификации (в десятых градуса Цельсия) в данном случае - это 10 десятых, то есть 1 градус Цельсия
int tEndRectOtbSR=985;  // Температура окончания отбора спирта-ректификата и начала отбора хвостов (в данном случе 96.5 С)
int tEndRect=985;       // Температура в кубе, при которой прекращается ректификация (в данном случе 99.5 С)
char minProcChimOtbSR=5;  // Минимальный ШИМ, за который нельзя выходить при отборе СР
char begProcChimOtbSR=100;  // Начальный ШИМ отбора СР
int ProcChimOtbCP=0;  // Процент ШИМ отбора голов при работе с царгой пастеризации положительные значения-отбор относительно отбора голов, отрицательные - абсолютное значение

char StateMachine=0; // Состояние конечного автомата процесса 
char flNeedReadAlarm;// Флаг того, что нужно анализировать состояние датчиков НПГ, Уровня в приемной емкости, Разлития по полу.
char flAlarmUroven=0; // Флаг того, что уровень в приемной емкости достик предела
char flAlarmMPX5010=0; // Флаг того, что уровень в приемной емкости достик предела
char flNoAlarmLowPower=NO_LOW_POWER_WARNING; // Флаг того, что не надо предупреждать о низком напряжении в сети (оно в общем-то важно только для ректификации и НБК).


char FlUsart=0; // Признак того, что надо вывести информацию на СОМ-порт
char flRing=0; // Признак наличия звонка от своего номера (запрос на СМС о состоянии процесса);

char flNeedAnalyse=0; // Флаг того, что надо анализировать результат измерения температуры
//char flStateProcess=0;
char flNeedScanKbd=0; // Флаг того, что надо читать состояние клавиш 
char flScanKbd; // Признак того, что в данный момент идет сканирование клавиатуры, состояние не менять.
char CountKeys;       // Переменная для защиты от дребезга
char secPressKeys;    // Признак того, сколько секунд нажата клавиша
unsigned char AddPressKeys=1;    // Признак того, сколько прибавлять значений, в зависимости от длительности нажатия клавиши.
unsigned char AddPressKeys10=10;   // Признак того, сколько прибавлять значений, в зависимости от длительности нажатия клавиши.
char CountState=0;     // Флаг того, что сохраняем состояние процесса (каждое значение - одна секунда)
char DispDopInfo=0;   // Флаг отображения дополнительной информации (через раз)
                      // 1 - смените емкость
                      // 2 - емкость с головами.
                      // 3 - низкое напряжение для поддержания мощности
                      // 4 - датчик ds18b20
                      // 5 - датчик давления MPX5010



char SlaveON=0;



// В этой переменной храним температуру в кубе для 
#define COUNT_CHIM 15
int tempK[COUNT_CHIM]={
  0  ,  880,  960,  1000,0,0,0,0,0,0,0,0,0,0,0};
char CHIM[COUNT_CHIM]={
  -1,   68,   25,  0,0,0,0,0,0,0,0,0,0,0,0};
// здесь храним количество значений в таблице (Отрицательные значения означают, что колнна находится в режиме само-обучения);
char CntCHIM=-4;
char flPopr; // Флаг поправки означает что в данный момент редактируется, температура или ШИМ 0-температура, 1- ШИМ.
#define MAX_CNT_PAUSE 16
char CntPause=8;
char tempP[MAX_CNT_PAUSE]={
  10,35,45,50,58,64,70,71,110,0,0,0,0,0,0,0};           // Температурные паузы в градусах (первое значение - это время работы насоса).
unsigned char timeP[MAX_CNT_PAUSE]={
  2,15,15,20,30,60,30,0,120,0,0,0,0,0,0,0};  // Время паузы в минутах (если 0, то это значит ожидаем действия пользователя (первое значение - это время паузы насоса). 

#define MAX_CNT_FRACTION_DIST 8
char CountFractionDist=0;
char CountFractionRect=0;
char TekFraction=0;
int TempFractionDist[MAX_CNT_FRACTION_DIST];
int PowerFractionDist[MAX_CNT_FRACTION_DIST];
unsigned char AngleFractionDist[MAX_CNT_FRACTION_DIST];
#define MAX_CNT_FRACTION_RECT 5
int TempFractionRect[MAX_CNT_FRACTION_RECT];
unsigned char AngleFractionRect[MAX_CNT_FRACTION_RECT];


char IncrementCHIM=0;
char DecrementCHIM=40;
int  TimeAutoIncCHIM=600;
int  TimeRestabKolonna=3600; // Время если в течении которого колонна не стабилизировалась, считаем новую температуру стабилизации

unsigned int KlOpen[MAX_KLP];  // Время закрытия клапанов (в полупериодах, то есть 100 - это примерно 1 секунда)
unsigned int KlClose[MAX_KLP];// Время открытия клапанов  (в полупериодах,то есть 100 - это примерно 1 секунда)
char KlState[MAX_KLP];         // Состояние клапанов (1 открыт - 0 закрыт) 
unsigned int  KlCount[MAX_KLP]; // Счетчик состояния клапанов
char KlReg[MAX_KLP];         // Режим работы
char KlSelect=0;  // Выбран режим прибавления - либо время открытия, либо время закрытия - это для ручного управления ШИМом, тестирования и прочего
char KlTek=0;     // Для отладки - режим какого клапана отображать на дисплее  - это для ручного управления ШИМом, тестирования и прочего .  
//char flSyncKLP=0; // Флаг того, что идет синхронизация клапанов, признак того, что состояние клапанов не менять.  
int Angle=0;


// Создаем LCD экран
char lcd_buffer[LCD_BUFFER_SIZE]; // предполагаем 2 байта на символ, в международной кодировке
#if USE_I2C_LCD
	LiquidCrystal_I2C lcd(LCD_I2C_ADDRESS, LCD_WIDTH, LCD_HEIGHT);
#else
	LiquidCrystal lcd(PIN_LCD_RS, PIN_LCD_EN, PIN_LCD_D4, PIN_LCD_D5, PIN_LCD_D6, PIN_LCD_D7);
#endif // USE_I2C_LCD


float MaxIOut;
float MaxVoltsOut;








char flAllOff;           // Флаг того, что все выключено

unsigned char Counter1=0;
long Seconds;   // Текущее состояние времени с начала процесса (не беззнаковое, потому, что есть проверки на <0);
long SecondsEnd;// Время окончания процесса 

char NeedDisplaying;
char flNoPhase=1;  // Переменная признак отключения фазового управления клапанов (например на период чтения датчиков температуры)
int resultU;
char NeedGPRS;

unsigned char StateVolts=0;  // Состояние вычисление среднеквадратичного 
//0 - надо вычислить - запускается старт, 1 - вычисляется, 2 - вычислено, 3 - идет обработка рузультата
// 4 - Результат обработан, можно вычислять следующий
int index_input=0; // Текущий размер массива дла расчета среднеквадратичного
int prev_index_input=0; // Текущий размер массива дла расчета среднеквадратичного
int indexOut=0;    // Размер для вывода на экран

unsigned char flCrossZero=0;
//unsigned int VoltsZr;
unsigned long TekPower;
unsigned long TekPowerKLP;
unsigned int TimeOpenTriac=0;
unsigned int TimeOpenTriacFact=0;
unsigned int TimeOpenKLP=0;
unsigned int TicZero; // Количество тиков таймера от нуля до нуля.
//char FirstRun;
// Установка мощности (Пока в виде переменных)

int Power=3000;       // Номинальная мощность ТЭНов
int PowerPhase[3]={
  3000,0,0};
unsigned char KtPhase[3]={
  100,100,100};
int FactPower=0;       // Номинальная мощность ТЭНов
int UstPower;     // Нужно получить мощность от регулятора (текущая мощность на всех фазах)
int UstPwrPH1;     // Нужно получить мощность от регулятора (текущая мощность на первой фазе)
int UstPwrPH2;     // Нужно получить мощность от регулятора (текущая мощность на первой фазе)
int UstPwrPH3;     // Нужно получить мощность от регулятора (текущая мощность на первой фазе)
int R_TEN20;        // Сопротиввление ТЭНов, умноженное на 10;

int UstPowerReg=1250;     // Мощность в режиме регулятора мощности

char flNeedTemp=0;    // Флаг того, что нужно читать температуру датчиков
char StepOut=0;       // Признак шага чтения температуры 0 - выдаем команду на запрос температуры
// 1 - читаем температуру

unsigned char CountAlarmVoda=0;       // Счетчик срабатываний датчика (если сработал три раза, тогда тревога)
unsigned char CountAlarmUroven=0;     // Счетчик срабатываний датчика (если сработал три раза, тогда тревога)
char CountGasSensor=0;                // Счетчик срабатываний датчика паров спирта (если сработал три раза, тогда тревога)



unsigned int BeepTime;
char StateNPG=0;   // Состояние автомата обработки НПГ
                  // 0 - не запускался
                  // 1 - инициализируется (наполнение)
                  // 2 - рабочий режим
                  // 3 - режим одного уровня тревоги (один раз считан нижний или верхний уровень)

int U_VODA=0,U_UROVEN=0,U_GAS=0,U_NPG=0,U_GLV=0; // Уровни воды, газа, НПГ, голов

#if SIMPLED_VERSION==2
  int UrovenProvodimostSR=1;   // Будем использовать датчик проводимости, как простой датчик уровня
#else
  int UrovenProvodimostSR=0;   // Уровень проводимости, меньше которого считаем, что закончились головы и начался спирт.
#endif


int UrovenBarda=250;        // Уровень сигнала, достижение котогого свидетельсвует о срабатывании датчика бардоотводчика.

char NpgDt;// 4- нет сработки датчика 1 - нижний уровень, 2 - рабочий, 3-верхний



//#define USE_BRESENHAM 0// Надо ли использовать брезинхем для управлением двигателем.

int deltaPower=0; // Разница мощности при дистилляции с дефлегматором.


char fl_read; // Признак того, что надо считать средреквадратичное

volatile bool bLCDclearFlag = false;


// Phisik: поддержка сортировки сенсоров
#if ENABLE_SENSOR_SORTING
	uint8_t ds1820_nums[MAX_DS1820] = {0, 1, 2, 3, 4};
#endif
